\documentclass[10pt,twocolumn,letter]{article}
\usepackage{styles/usenix-style}
\usepackage{styles/ka-style}
\usepackage{xspace,ifthen,graphicx,listings}
\usepackage{styles/ka-style}

\usepackage[utf8]{inputenc}
\usepackage[inline]{enumitem}
\usepackage{parskip} % disable indentation for new paragraphs, increased margin-bottom instead
\usepackage[english]{babel}
\usepackage{csquotes}
\usepackage[style=alphabetic]{biblatex}
\addbibresource{literature.bib}

\usepackage[
   pdfauthor={Christian Schwarz},
   pdftitle={Seminar Report - Light Weight Contexts},
   pdfsubject={An OS Abstraction for Safety and Performance}, 
   pdfkeywords={}
]{hyperref}

\setlength{\marginparwidth}{2cm} % to make todonotes fit in twocolumn
\usepackage{todonotes}

\usepackage{blindtext}
\usepackage{listings}

\begin{document}
\title{%
  % document class article doesn't support subtitles, let's hack them
  {\normalfont \normalsize Seminar Report on}\\%
  Light Weight Contexts\\%
  {\normalfont \normalsize An OS Abstraction for Safety and Performance}\\%
  {\normalfont \small %
    James Litton\textsuperscript{1,2}
    Anjo Vahldiek-Oberwagner\textsuperscript{2}
    Eslam Elnikety\textsuperscript{2}
    Deepak Garg\textsuperscript{2}
    Bobby Bhattacharjee\textsuperscript{1}
    Peter Druschel\textsuperscript{2}
  }\\
  {\normalfont \small
    \textsuperscript{1}University of Maryland, College Park 
    \textsuperscript{2}Max Planck Institute for Software Systems
  }%
}
\author{Report by Christian Schwarz}
\date{2019}

\maketitle

\begin{abstract}
  \blindtext
\end{abstract}

\section{Introduction}\label{intro}

Application Compartmentalization as in seminar presentation. Ignore Session Isolation \& Snapshots?

Line of throught:

Modern app architecture commonly emphasizes modularization \& information hiding (Parnas) to achieve testability, maintainability, exchangability, reusability.
The extreme of reusability are large libraries used by multiple independent applications.

However, chasm between development time and runtime:
PLs enforce encapsulation at compile time, but the resulting program runs in a single protection domain, i.e. a process, at runtime:
shared address space with shared heap, shared file descriptor table, shared system-level privilege (user id, group id, capabilities(SYS\_CAP\_), system call) between all modules of the program.
Consequently, an exploitable vulnerability in a single module not only compromises that module but the entire application.

The generic solution: decomponsition of the application into smaller units that execute in separate protection domains.
Generic questions / problems / tradeoffs:
\begin{itemize}
  \item threat model
  \item definition of what makes a protection domain
  \item how to integrate the decomposition into different protection domains into the PL / runtime?
  \item applicability to existing PLs \& code bases
  \item how to maintain application performance
\end{itemize}

\subsection{Structure of this Report}
\blindtext


\section{Design}\label{design}
We find it most helpful to develop the general idea of \textit{light weight Contexts} (lwCs) by starting from the canonical abstraction of processes \& threads, as visualized in figure~\ref{design:fig:canonicalprocthreads}.
\begin{figure}
  \label{design:fig:canonicalprocthreads}
  \includegraphics[width=\linewidth]{fig/canonical-proc-thread-relationship}
  \caption{
    Canonical state associated with processes and threads and the relationship between them.
    The process implicitly defines the execution environment for threads.
    Threads are scheduling entities that represent a single control flow bound to the process-defined environment.
  }
\end{figure}
Conventionally, processes define an execution environment which is shared by one or more threads.
The execution environment consists of an address space, a file descriptor table and a representation of the process's system-wide privileges (\textit{credential}).
A thread has \textbf{two closely related, but separate roles}:
\textbf{first}, it represents a \textbf{single unit of logical control flow} within the process-defined environment.
Control flow has associated state, e.g., instruction pointer, stack pointer, general purpose register contents, FPU state, etc.
That state resides in a CPU's registers while the thread is executing on a CPU, or in the thread control block (TCB) kernel data structure.
The \textbf{second} role of a thread is that of a \textbf{scheduling entity}:
The scheduler time-multiplexes threads onto CPU cores and implements the concept of blocking \& waiting between threads.
The scheduler state required for this task is stored in the thread control block (TCB).

The authors introduce \textit{light weight contexts} (lwCs) as a new OS abstraction and restructure the roles of canonical processes \& threads, as visualized in figure~\ref{design:fig:lwcprocthreadrelationship}:

\begin{figure}[h]
  \label{design:fig:lwcprocthreadrelationship}
  \includegraphics[width=\linewidth]{fig/lwc-proc-thread-relationship}
  \caption{
    State associated with lwCs, processes and threads and relationships between them.
    Processes act as containers for threads and lwCs.
    Threads are reduced to their role as scheduling entities.
    Each lwC represents an execution environment and holds control flow state for each thread.
  }
\end{figure}

\begin{itemize}
\item An lwC represents a single protection domain (address space, file descriptor table and system credential) and logical control flows within that protection domain.
\item Each thread that can enter an lwC has aexecutes the At thread is always associated with exaclty one lwC at any given time.
\item Within an lwC, a thread executes a logical control flow 
\item Multiple threads can execute simultaneously within an lwCs, sharing a protection domain but executing different logical flows.
\item lwCs are represented as file descriptors, and thus explicitly tangible by user space.
\item Threads can switch protection domains and logical control flow by switching between lwCs.
\end{itemize}

In the following subsections, we provide an outline of the system API for managing and using lwCs in an application.
Subsequently, we summarize the security guarantees provided by lwCs and provide usage examples for this new OS abstraction. 

\subsection{lwC Switching}\label{design:switching}
Threads can switch between lwCs using the \lstinline{lwcSwitch} system call:

\begin{lstlisting}[float=h]
  caller, carg := lwcSwitch(target, arg) 
\end{lstlisting}

The first argument \lstinline{target} specifies the file descriptor of the lwC into which the calling thread wants to switch%
\footnote{We will come back to lwC creation in the next subsection, and accept the existence of multiple lwCs for now.}

When invoking the system call, the kernel performs the following actions:

The second argument \lstinline{arg} is an opaque value that is made available to  made available 
\begin{enumerate}
  \item Save the current state into 
\end{enumerate}

The second argument \lstinline{arg} is an opaque value which is made available on the 


Switching to a new lwC yields control flow 
resume logical control flow a thread to switch and resume between protection domains and logical control flows using the \lstinline{lwcSwitch} system call.


\subsection{lwC Creation \& Destruction}\label{design:createdestroy}

\subsubsection{lwC Resource Specifiers}\label{design:rspecs}
\subsubsection{Static Resource Sharing}

\subsection{Dynamic Resource Sharing with lwC Overlays}\label{design:overlays}

\subsection{Syscall Interposition}\label{design:syscallinterpos}

\subsection{Threat Model \& Security Guarantees}\label{design:threat}

\subsection{Usage Examples}\label{design:usage}

\section{Implementation \& Evaluation}\label{eval}

\subsection{Evaluation Critique}\label{eval:crit}

\section{Related Work}\label{rel}

\begin{itemize}
  \item Application Compartmentalization
  \begin{itemize}
    \item Principle of least Privilege
    
    \item Language-Technology-Based
    \begin{itemize}
      \item NaCL \& WASM
      \item BPF \& eBPF
      \item Software Fault Isolation
      \item Memory-safe Runtime (Java, CLR?) %working title, need proper PL word for it
    \end{itemize}
    
    \item OS-Based
      \begin{itemize}
        \item Capability Systems
        \begin{itemize}
          \item Fiasco-OC / seL4
          \item FreeBSD Capsicum
        \end{itemize}
        \item Process-Based Privsep
        \begin{itemize}
          \item Provos, OpenSSH
        \end{itemize}
        \item Hybrids (isolation at some level)
        \begin{itemize}
          \item wedge
          \item shreds (uses ARM memory domains)
          \item \textbf{light weight contexts}
        \end{itemize}
      \end{itemize}

    \item Hardware-Based
    \begin{itemize}
      \item CHERI
    \end{itemize}
  \end{itemize}
  
  \item Process Snapshotting \& Rollback
  \item Session Isolation in CGI applications?
\end{itemize}

\section{Conclusion}\label{conclusion}

% Cite all the literature, not just the one we referenced in the text.
\nocite{*}
\clearpage
\printbibliography

\end{document}
