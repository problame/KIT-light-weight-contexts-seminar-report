\documentclass[10pt,twocolumn,letter]{article}
\usepackage{styles/usenix-style}
\usepackage{styles/ka-style}
\usepackage{xspace,ifthen,graphicx,listings}
\usepackage{styles/ka-style}

\usepackage[utf8]{inputenc}
\usepackage[inline]{enumitem}
\usepackage{parskip} % disable indentation for new paragraphs, increased margin-bottom instead
\usepackage[english]{babel}
\usepackage{csquotes}
\usepackage[style=alphabetic]{biblatex}
\addbibresource{literature.bib}

\usepackage[
   pdfauthor={Christian Schwarz},
   pdftitle={Seminar Report - Light-Weight Contexts},
   pdfsubject={An OS Abstraction for Safety and Performance}, 
   pdfkeywords={}
]{hyperref}

\setlength{\marginparwidth}{2cm} % to make todonotes fit in twocolumn
\usepackage{todonotes}

\usepackage{blindtext}

\usepackage{listings}
\lstdefinestyle{lwcapi}{language=[ANSI]C,basicstyle=\ttfamily,basewidth=0.5em,fontadjust=true}
\lstset{style=lwcapi}

\usepackage{diagbox}
\usepackage{multirow}

\begin{document}
\title{%
  % document class article doesn't support subtitles, let's hack them
  {\normalfont \normalsize Seminar Report on}\\%
  Light-weight Contexts\\%
  {\normalfont \normalsize An OS Abstraction for Safety and Performance}\\%
  {\normalfont \small %
    James Litton\textsuperscript{1,2}
    Anjo Vahldiek-Oberwagner\textsuperscript{2}
    Eslam Elnikety\textsuperscript{2}
    Deepak Garg\textsuperscript{2}
    Bobby Bhattacharjee\textsuperscript{1}
    Peter Druschel\textsuperscript{2}
  }\\
  {\normalfont \small
    \textsuperscript{1}University of Maryland, College Park 
    \textsuperscript{2}Max Planck Institute for Software Systems
  }%
}
\author{Report by Christian Schwarz}
\date{2019}

\maketitle

\begin{abstract}
  \blindtext\todo{fix blindtext}
\end{abstract}

\section{Introduction}\label{intro}

Application Compartmentalization as in seminar presentation. Ignore Session Isolation \& Snapshots?

Line of throught:

Modern app architecture commonly emphasizes modularization \& information hiding (Parnas) to achieve testability, maintainability, exchangability, reusability.
The extreme of reusability are large libraries used by multiple independent applications.

However, chasm between development time and runtime:
PLs enforce encapsulation at compile time, but the resulting program runs in a single protection domain, i.e. a process, at runtime:
shared address space with shared heap, shared file descriptor table, shared system-level privilege (user id, group id, capabilities(SYS\_CAP\_), system call) between all modules of the program.
Consequently, an exploitable vulnerability in a single module not only compromises that module but the entire application.

The generic solution: decomponsition of the application into smaller units that execute in separate protection domains.
Generic questions / problems / tradeoffs:
\begin{itemize}
  \item threat model
  \item definition of what makes a protection domain
  \item how to integrate the decomposition into different protection domains into the PL / runtime?
  \item applicability to existing PLs \& code bases
  \item how to maintain application performance
\end{itemize}

\subsection{Structure of this Report}
\blindtext\todo{fix blindtext}


\section{Design}\label{design}
We find it most helpful to develop the general idea of \textit{light-weight Contexts} (lwCs) by starting from the canonical abstraction of processes \& threads, as visualized in figure~\ref{design:fig:canonicalprocthreads}.
\begin{figure}
  \label{design:fig:canonicalprocthreads}
  \includegraphics[width=\linewidth]{fig/canonical-proc-thread-relationship}
  \caption{
    Canonical state associated with processes and threads and the relationship between them.
    The process implicitly defines the execution environment for threads.
    Threads are scheduling entities that represent a single control flow bound to the process-defined environment.
  }
\end{figure}
Conventionally, processes define an execution environment which is shared by one or more threads.
The execution environment consists of an address space, a file descriptor table and a representation of the process's system-wide privileges (\textit{credential}).
A thread has \textbf{two closely related, but separate roles}:
\textbf{first}, it represents a \textbf{single unit of logical control flow} within the process-defined environment.
Control flow has associated state, e.g., instruction pointer, stack pointer, general purpose register contents, FPU state, etc.
That state resides in a CPU's registers while the thread is executing on a CPU, or in the thread control block (TCB) kernel data structure.
The \textbf{second} role of a thread is that of a \textbf{scheduling entity}:
The scheduler time-multiplexes threads onto CPU cores and implements the concept of blocking \& waiting between threads.
The scheduler state required for this task is stored in the thread control block (TCB).

The authors introduce light-weight contexts as a new OS abstraction and restructure the roles of canonical processes \& threads, as visualized in figure~\ref{design:fig:lwcprocthreadrelationship}:

\begin{figure}[h]
  \label{design:fig:lwcprocthreadrelationship}
  \includegraphics[width=\linewidth]{fig/lwc-proc-thread-relationship}
  \caption{
    State associated with lwCs, processes and threads and relationships between them.
    Processes act as containers for threads and lwCs.
    Threads are reduced to their role as scheduling entities.
    Each lwC represents an execution environment and holds control flow state for each thread.
  }
\end{figure}

\begin{itemize}
\item An lwC represents a single protection domain (address space, file descriptor table and system credential) and all logical control flows within that protection domain.
\item Threads always execute within one lwC at any given time and always execute the same logical control flow while within that lwC.
\item Multiple threads can execute simultaneously within an lwCs, sharing a protection domain but executing different logical flows.
\item lwCs are represented as file descriptors, and thus explicitly tangible from user space.
\item Threads can switch protection domains and logical control flow by switching between lwCs.
\end{itemize}

In the following subsections, we provide an outline of the system API for managing and using lwCs in an application.
Subsequently, we summarize the security guarantees provided by lwCs and provide usage examples for this new OS abstraction. 

\subsection{lwC Switching}\label{design:switching}
We start our survey of the lwC API surface with the most central functionality: switching between lwCs.
We accept the existence of multiple lwCs for now and come back to lwC creation in the next subsection.

Threads can switch between lwCs by invoking the \lstinline{lwcSwitch} system call:

\begin{lstlisting}[float=h]
  caller, carg := lwcSwitch(target, arg) 
\end{lstlisting}

The first argument \lstinline{target} specifies the file descriptor of the lwC into which the calling thread wants to switch.
When invoking the system call, the kernel
\begin{enumerate}[label=(\alph*)]
\item saves the current control flow state into the current thread's lwC,
\item atomically switches to the new protection domain by installing the target lwC address space, file descriptor table and credential for the current thread,
\item and restores the control flow state saved for the current in thread in the target lwC.
\end{enumerate}
Pseudo code for this procedure is provided in listing~\ref{design:fig:switchpseudocode}.

\begin{lstlisting}[mathescape,label=design:fig:switchpseudocode,caption=Pseudo code for lwcSwitch.,frame=trbl]
  syscall
  
  SP, IP, $\dots$ $\rightarrow$ curLWC->tcb[tid]
  
  curThd->vmspace = targetLWC->vmspace
  curThd->fdt = targetLWC->fdt
  curThd->cred = targetLWC->cred
  curLWC = targetLWC
  
  SP, IP, $\dots$ $\leftarrow$ targetLWC->tcb[tid]
  (arg kept in register)
  
  sysret  
\end{lstlisting}
  
It is crucial to understand that \textbf{execution after a switch always resumes at an lwC call site}, except for the very first switch into a newly created lwC (see section~\ref{design:createdestroy}).
Note that this behavior is analogous to a voluntary context switch, e.g., with \lstinline{pthread_yield}.
However, in contrast to the canonical model of processes \& threads, \textbf{\lstinline{lwcSwitch} does not switch to another scheduling entity}:
from the thread scheduler's perspective, it is still the same thread that is executing on the CPU.
In fact, \textbf{the thread scheduler is not affected at all by lwC switching}:
it still handles context switches post-interrupt, post-exception or when a thread blocks, by simply saving that thread's control flow state to the slot in the current lwC before switching to another thread (i.e.~scheduling entity).

The second argument to \lstinline{lwcSwitch} is an opaque value called \lstinline{arg} that is passed through to the code that starts executing in the target lwC after the switch is completed.
\lstinline{arg} is made available in the target lwC as the return value \lstinline{carg} (we remember that execution always resumes at an lwC call site).
The second return value \lstinline{caller} is the file descriptor of the lwC from where the switch was initiated.
Having this information available in the switch target enables subroutine-style usage of \lstinline{lwcSwitch} because it enables switching back to any number of callers that are unknown at compile time.

% do not mention coroutines here, will do that in the application

\subsection{lwC Creation \& Destruction}\label{design:createdestroy}
A process in an lwC system starts with a single thread that runs within a root lwC created by the OS.
This design enables backwards binary-compatiblity with the exception that the root lwC file descriptor is a well-known number analogous to those for stdio.

New lwCs can then be created by threads using the \lstinline{lwcCreate} system call:

\begin{figure}[h]
  \centering
\begin{lstlisting}[mathescape]
  new, caller, carg := lwcCreate(rspecs)
\end{lstlisting}
\begin{tabular}{|r||c|c|c|}
  \hline
                &   new        & caller       & carg \\
  \hline\hline
  creator       & new lwC fd   & $\bot$      & $\bot$\\
  \hline
  new lwC       &    creator lwC fd   & \multicolumn{2}{c|}{like lwcSwitch}\\
  \hline
\end{tabular}
\caption{
  \texttt{lwcCreate} return values are different in creator and new lwC to ensure well-defined behavior when the creator switches to the new lwC for the first time.
}
\end{figure}

By default, a new lwC is a snapshot of the calling thread's current lwC, as depicted in figure~\ref{design:fig:lwccreationsequencediagram}:
The kernel first creates copies of the resources \textit{address space}, \textit{file descriptor table} and \textit{credentials} and stores them in the new lwC.
It then temporarily preempts all threads that execute in the current lwC and stores their control flow state in the new lwC.
The execution state of other threads that can switch to the creating lwCs is simply copied to the new lwC.
Finally, the file descriptor referring to the new lwC is returned to user space in the return value \lstinline{new}.

\begin{figure}
  \centering
  \includegraphics[height=4cm]{fig/lwc-creation-sequence-diagram}
  \caption{
    Steps involved in lwC creation.
    By default, a new lwC is a copy (snapshot) of the current lwC's resources.
    All threads that exist at the time of lwC creation can enter the new lwC.
  }
\label{design:fig:lwccreationsequencediagram}
\end{figure}

Note that in contrast to the original paper, we avoid the term \textit{fork} when describing the lwC creation procedure:
forking has the same resource snapshotting semantics as \textit{lwcCreate}, but also implies the creation of a new process and scheduling entity.
In contrast, \textit{lwcCreate} only creates a copy of the protection domain and a handle for existing threads to switch to it later --- no independent scheduling entity is created.

However, one problem of forking translates to lwC creation:
\textbf{what happens when we first switch into a newly created lwC? How does snapshotting interact with multi-threading?}
After all, we preempt and snapshot all threads' control flow states on lwC creation, and the \lstinline{lwcSwitch} implementation restores that state on first switch, expecting that it was an \lstinline{lwcSwitch} call site.
We need to consider two cases:
the \lstinline{lwcCreate}ing thread will appear return "a second time" from that syscall and populate \lstinline{lwcCreate}'s \lstinline{caller} and \lstinline{carg} return values with those of \lstinline{lwcSwitch}.
Additionally, the \lstinline{new} contains the lwC descriptor of the creator lwC.
The behavior in the creating thread is thus well-defined.
Other threads could be at random points in their logical control flow when being snapshotted, resulting in undefined behavior after the switch.\todo{obvious?}
Multithreaded forking is a well-known problem, \todo{citation} and the authors recommend applications to use barrier-synchronization with the creator.\todo{cite}
However, it is unclear to us how the \lstinline{caller} and \lstinline{carg} return values are accessible without inline-assembly or language support for non-creator threads.\todo{check}

Finally, it should be noted that a new lwC only stores control flow states for the threads that existed at the time of its creation:
threads created after the lwC cannot switch into the lwC.

\subsubsection{lwC Resource Specifiers}\label{design:rspecs}
The previous section presented the default behavior of \lstinline{lwcCreate} for an empty \lstinline{rspecs} argument, which amounts to the new lwC being a snapshot copy of the current lwC's \textbf{resources} \textit{address space}, \textit{file descriptor table} and \textit{credential}.
By using \textit{resource specifiers}, the application can control resource sharing at a more fine-grained level:
resources of the current lwC can be either \textit{copied to}, \textit{unmapped from} or \textit{shared} with the new lwC.
For address space and file descriptors, different sharing behavior can be specified on a per-page or per-descriptor basis.
Figure~\ref{design:fig:rspectable} summarizes the different combinations of resources and sharing behavior.

\begin{figure}[h]
  \centering
\begin{lstlisting}
rspecs := [{Resource , [Start, End), How}]
\end{lstlisting}

\begin{tabular}{|r||m{1.5cm}|m{1.5cm}|m{1.5cm}|}
  \hline
  \diagbox[width=5em]{How}{What}    &     Address Space         &         File Descriptor Table         &           Credential           \\
  \hline
  COPY                              &   copy on write sharing           &      \texttt{dup} open FDs once    &  copy credential kobject  \\
  \hline              
  UNMAP                             &   do not map              &       do not \texttt{dup} FDs         &    $\bot$       \\
  \hline              
  SHARE                             &   shared memory            &   share kobject   &             share kobject   \\
  \hline
\end{tabular}
\caption{
  Resource specifiers change the default snapshot semantics of \texttt{lwcCreate}:
  each resource can be copied, shared or unmapped from the new lwC.
  Address space and file descriptor sharing can be configured per page / per descriptor.
  \textit{copy} sharing is roughly equivalent to what happens on \texttt{fork}, \textit{share} to what happens on thread creation.
  }
\label{design:fig:rspectable}
\end{figure}
\todo{language, prettier table}

\subsection{Dynamic Resource Sharing with lwC Overlays \& Access Capabilities}\label{design:overlays}
Apart from sharing at lwC creation time, it is also possible to dynamically copy or share memory and file descriptors between lwCs or to temporarily escalate system privileges to the credential of another lwC through the \lstinline{lwcOverlay(src, rspecs)} system call.
The \lstinline{src} argument is the file descriptor of the lwC from which the subset of resources specified in \lstinline{rspecs} should be mapped (\textit{overlaid}) into the current lwC.
The target address (for memory overlays) or file descriptor number is guaranteed to be the same as in \lstinline{src}.
To unmap an existing overlay, \lstinline{src} must be set to the current lwC and \lstinline{rspecs} must be filled with \lstinline{UNMAP} resource specifiers. 
Overlays do not support stacking: after unmapping an overlay that overlaid an existing memory mapping, that original memory mapping is not automatically remapped.\todo{proof by code}  %vmspace_lwc_merge

Overlaying resources from an lwC descriptor \lstinline{src} further requires that this descriptor is equipped with \textbf{access capabilities} for each requested resource.
The rules of this capability system are as follows:
\begin{itemize}
  \item After lwC creation, the creator receives the \lstinline{new} lwC descriptor with a universal access capability to the child lwC.
  \item After lwC creation, the child receives the lwC descriptor of its creator in \lstinline{new}, equipped with access capabilities to ranges flagged with \lstinline{LWC_MAY_ACCESS} on lwcCreate.
  \item Access capabilities cannot be extended.
  \item Access capabilities can be reduced with the \lstinline{lwcRestrict(target, rspecs)} system call by any lwC that holds the lwC descriptor \lstinline{target}:
        after a successful \lstinline{lwcRestrict}, the resource ranges specified in \lstinline{rspecs} can no longer be overlaid using \lstinline{lwcOverlay(target, ...)}.
  \item Access capabilities are invariant across overlays: to the file descriptor entry in the kernel, and is therefore invariant across overlays.
\end{itemize}

In order to grasp the access capability system, we find it helpful to peek at the authors' implementation.
The access capabilities associated with an lwC descriptor are represented as an \lstinline{rspecs} in lwC file descriptor table entry (\lstinline{struct filedescent}).
The overlay permission check enforces that the requested overlay rspec is a subset of the rspec in that file descriptor table entry.

Note that revocation of existing overlays is not possible, i.e., \lstinline{lwcRestrict} only affects future overlays.\todo{proof, not mentioned in paper / impl. see microkernel discussions}

\subsection{Syscall Interposition in Capability Mode}\label{design:syscallinterpos}
% kernel: lwctrapto in sys/kern/subr_syscall.c basically just calls lwcswitch 
When compartmentalizing an application into different lwCs, it can be desirable to limit the system calls an lwC may perform, e.g., to limit filesystem access to a subdirectory or prohibit network communication.
The lwC design builds onto existing syscall filtering and mechanisms, e.g. Capsicum capability mode on FreeBSD or seccomp on Linux\todo{cite}:
when an lwC is created with the \lstinline{LWC_TRAP_SYSCALL} flag, system calls made by the new lwC or any of its children that would normally trap due to the syscall filtering mechanism are redirected to the creator as an \lstinline{lwcSwitch} with \lstinline{caller} set to the trapping lwC.
After the trap-handling lwC has evaluated its policy, the \lstinline{lwcSyscall} system call provides the mechanism for the trap-handling lwC to execute any system call (the original one, another one) \textbf{in the context of the trapping lwC}:

\begin{lstlisting}[float=h]
  lwcSyscall(trappingLwc, mask,
             syscall, syscall-args)
\end{lstlisting}

An alternative design could require the trap-handling lwC to invoke the allowed syscalls itself and return the result as the opaque argument in an \lstinline{lwcSwitch} to the trapping lwC.
However, if the syscall arguments contain pointers to user memory or file descriptors, the trap-handling lwC would need to overlay those from the trapping lwC.
\lstinline{lwcSyscall} avoids the associated overhead:
the \lstinline{mask} argument allows the trap-handling lwC to choose per resource type\footnote{granularity: all memory, all file descriptors, the credential} whether its own mapping or that of the trapping lwC should be used while the syscall is executed.
Note that \lstinline{lwcSyscall} this mechanism is still integrated with the access capability system explained in the previous section:
the \lstinline{trappingLwc} descriptor must be equipped with access capabilities for the resource types that \lstinline{mask} specifies.

\subsection{Summary}
\todo{forking \& signal semantics? just skip them?}

\todo{TODO}
% TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO TODO 
\begin{figure}[h] % TODO make this a broad figure?
\centering
\begin{tabular}{|r|m{1.5cm}|}
  \hline
  lwcCreate & \\
  \hline
  lwcClose & \\
  \hline
  lwcGetLwc & \\
  \hline
  lwcSwitch &  \\
  \hline
  lwcOverlay & \\
  \hline
  lwcRestrict & \\
  \hline
  lwcSyscall & \\
  \hline
\end{tabular}
  \caption{lwc API summary table}
\end{figure}


\subsection{Threat Model \& Security Guarantees}\label{design:threat}

In this subsection, we are going to define a threat model for lwCs and assess how the design meets the canonical information security properties of \textit{confidentiality}, \textit{integrity} and \textit{availability}\cite{ciagoals}.

\textbf{Threat Model}\hspace{1em}
The run-time trusted computing base of an application that uses light-weight contexts is the
hardware, firmware, (monolithic) OS kernel and the any user space code that runs before \lstinline{main} starts executing.
Hardware-based attacks are excluded unless mitigated by the OS, including side-channels and exploitation of out-of-order \& speculative execution.\todo{correct to exclude ooo and spec}
The threat model \& guarantees of kernel subsystems apart from the new lwC subsystem is inherited, including isolation guarantees between processes, as lwCs only affect a single process\todo{and its forks...}.
Malicious interference of high-privileged processes is excluded.
With regards to the implementation, it is assumed that all subsystems use correct accessor functions for a thread's address space, file descriptor table and credential, instead of relying on the assumption that there is only one of those resources per process.

\textbf{Security Guarantees}\hspace{1em}
Light-weight contexts can be used to create multiple protection domains within a single process,
each with a private \textit{address space}, \textit{file descriptor table} and the system \textit{credential} and private per-thread logical control-flow state (section~\ref{design:createdestroy}).
Switching between the domains and single-value argument passing is controlled by the kernel (section~\ref{design:switching}).
Dynamic sharing of resources between lwCs is also kernel-controlled using access capabilities (section~\ref{design:overlays}).
Access to global namespaces \& system resources (IP sockets, filesystem, IPC) is limited by the lwC's \textit{credential} and can be further controlled through syscall interposition (section~\ref{design:syscallinterpos}).

Kernel-controlled switching between lwCs results in \textbf{well-defined entry points} under the assumption of an lwC created using \lstinline{COPY} resource specifier\todo{this is quite coarse, AS and FDT sufficient?}:
the first \lstinline{lwcSwitch} diverts physical control flow to the \lstinline{lwcCreate} call site in the new lwC, and all subsequent \lstinline{lwcSwitch}es resume execution at an lwcSwitch all site.
Under the assumption of no dynamic sharing, the address space of the target lwC is inaccessible to any caller.
Thus, integrity and confidentiality guarantees for code and data within an lwC are those of the application code creating the lwC and those of the code executing in the target lwC after \lstinline{lwcSwitch}.
The result is a narrow, auditable interface.

Privsep through credentials, system wide \& global namespaces

availability not guaranteed at all


\subsection{Use Cases \& API Examples}\label{design:usage}

\subsection{Limitations}

\section{Implementation \& Evaluation}\label{eval}

\subsection{Critique}\label{eval:crit}

\section{Related Work}\label{rel}

\begin{itemize}
  \item Application Compartmentalization
  \begin{itemize}
    \item Principle of least Privilege
    
    \item Language-Technology-Based
    \begin{itemize}
      \item NaCL \& WASM
      \item BPF \& eBPF
      \item Software Fault Isolation
      \item Memory-safe Runtime (Java, CLR?) %working title, need proper PL word for it
    \end{itemize}
    
    \item OS-Based
      \begin{itemize}
        \item Capability Systems
        \begin{itemize}
          \item Fiasco-OC / seL4
          \item FreeBSD Capsicum
        \end{itemize}
        \item Process-Based Privsep
        \begin{itemize}
          \item Provos, OpenSSH
        \end{itemize}
        \item Hybrids (isolation at some level)
        \begin{itemize}
          \item wedge
          \item shreds (uses ARM memory domains)
          \item \textbf{light weight contexts}
        \end{itemize}
      \end{itemize}

    \item Hardware-Based
    \begin{itemize}
      \item CHERI
    \end{itemize}
  \end{itemize}
  
  \item Process Snapshotting \& Rollback
  \item Session Isolation in CGI applications?
\end{itemize}

\section{Conclusion}\label{conclusion}

% Cite all the literature, not just the one we referenced in the text.
\nocite{*}
\clearpage
\printbibliography

\end{document}
